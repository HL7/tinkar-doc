<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../../../docbook-customization/src/docbkx-stylesheet/common/komet.rnc" type="application/relax-ng-compact-syntax"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <title>Tinkar Reference Model</title>
    <para>This section describes classes of objects that support a common foundational framework for
        terminology and knowledge base systems (e.g. SNOMED CT, LOINC<sup>®</sup>, RxNorm, HL7,
        etc.). </para>
    <para>Model Representation - The Tinkar Reference Model is a logical model described herein
        using the Object Management Group (OMG) Unified Modeling Language (UML) 2.0 notation to
        describe the structure of integrated data representation and change management for
        biomedical terminologies. </para>
    
    <section>
        <title>Standard Class Model</title>
        <para>
            <figure>
            <title>Versioned Component</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Versioned_Component.png" scalefit="1" width="100%" contentdepth="100%"/>
                </imageobject>
            </mediaobject>
            <caption>
                    <para><emphasis role="italics">Versioned Component</emphasis>
                    </para>
                </caption>
            </figure>
        </para>
        <para>The Tinkar Reference Model fulfills the requirement of capturing a complete record of
            all changes, including relevant context information
            (<?oxy_comment_start author="timowilliams" timestamp="20210218T094737-0600" comment="Add links back to the requirement chapter for each of these"?>Requirement
            18<?oxy_comment_end?>).  This is captured via the STAMP class using the following
            fields: </para>
        <para>
            <orderedlist>
                <listitem>
                    <para><emphasis role="bold">Status:</emphasis> A status is identified by a
                        concept, which may be annotated with other identifying information. For
                        example: active or inactive (Requirement 20)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Time:</emphasis> Timestamps must employ a common
                        standard, which must support precision and time zone. (Requirement
                        21)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Author:</emphasis> An author is identified by a
                        concept, which may be annotated with other identifying information as
                        required. (Requirement 22)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Module: </emphasis>Assignment to the appropriate
                        terminology (e.g., LOINC) or terminology component (e.g., SNOMED CT, US
                        Extension). A module is identified by a concept, which may be annotated with
                        other identifying information. (Requirement 23) </para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Path:</emphasis> Specification of a branch within a
                        terminology development lifecycle, e.g., for distributed development,
                        testing, staging, or production. A path is identified by a concept, which
                        may be annotated with other identifying information. A core set of paths is
                        necessary to support publication to external organizations. (Requirement
                        24)</para>
                </listitem>
            </orderedlist>
        </para>
                    <para>These elements together are referred to by the acronym “<emphasis
                role="bold">STAMP</emphasis>”. Every new assertion, whether a new component or a
            change to an existing component, must have a STAMP in order to determine when it is to
            be used. The STAMP properties support the ability to apply terminology components for
            specific purposes. For example, <itemizedlist>
                <listitem>
                    <para>“Path” can be used to test provisional content without physically swapping
                        out systems.</para>
                </listitem>
                <listitem>
                    <para>“Module” can be used to filter out work that has not been authorized by
                        the enterprise.</para>
                </listitem>
                <listitem>
                    <para>“Time” supports the ability to apply CDS rules as they would have looked
                        in the past. </para>
                </listitem>
            </itemizedlist>The Tinkar model does not merely support the ability to “STAMP”
            components: it asserts a requirement that all changes have a STAMP. STAMP assertions are
            unversioned IdentifiedComponents that are referenced by the components they scope. Since
            STAMP uses versioned concepts (that have a STAMP), having the STAMP as a versioned
            component would lead to an infinite regress. </para>
        <para>All IdentifedComponents in the knowledge base will consist of a series of change
            records, called ComponentVersions, (beginning with the “Create” version), all associated
            to an underlying ComponentChronology.</para>
        
        <para>A Components Chronology only has properties inasmuch as they are attributed to it by
            its versions. Looking at the IdentifiedComponent through different sets of changes
            (published version, geographically defined set of modules, historical timestamp) may
            reveal substantially different IdentifedComponents. </para>
    </section>
    <section>
        <title>Component Types</title>
        <para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Identified_Componentsv2.png" scalefit="1" width="100%"
                        contentdepth="100%"/>
                </imageobject>
            </mediaobject>
        </para>
        <para>All Components in Tinkar are uniquely identified using UUIDs. A Component will be
            represented by an array of UUID's with at least one UUID, but can be represented by more
            than one UUID in the case of a concept being derived from multiple sources. For example,
            the concept Acetaminophen (which exists in SNOMED, LOINC, and RxNorm) would have a UUID
            from each terminology and be represented as an array of UUID's for this single concept
            within a Tinkar implementation. </para>
        <para>To assemble groups of assertions and to provide information about Concepts, Tinkar
            uses a construct called a <emphasis role="bold">Semantic</emphasis>. A Semantic is a
            collection of values that supports the specification of value sets, compositional
            definitions, and other components requiring internal structure, and it specifies the
            nature of the compositional relationship explicitly. </para>
        <para>The Semantic class uses a Concept to define the relationship between the value(s) and
            the Concept; the value itself may be either a concept or some other kind of data type,
            such as a string. We then create the ability to assemble assertions into more complex
            structures. <figure>
                <title>Compositional Semantics</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Compositional_Semantics.png" format="PNG" scalefit="1"
                            width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Compositional Semantics</emphasis></para>
                </caption>
            </figure></para>
        <para>As discussed earlier, if an author makes a change to an IdentifiedComponent, the prior
            Version is unchanged, but a new version – with the appropriate STAMP information – is
            recorded. Users viewing the Concept and associated Semantics in the prior context (i.e.,
            as of the prior time, if no other STAMP element has changed) will see the old values;
            users viewing the Concept and associated Semantics in the new context will see the new
            values.</para>
        <para>Since it is versioned, a Semantic is manifest as a <emphasis role="bold"
                >SemanticChronology</emphasis>, containing a set of <emphasis role="bold"
                >SemanticVersions</emphasis>. Concepts, too, are manifest as collections: a
                <emphasis role="bold">ConceptChronology</emphasis> consisting of a set of <emphasis
                role="bold">ConceptVersions</emphasis>.</para>
        <para>If other IdentifiedComponents depend on the changed concept, they can be identified by
            relationships in the Semantics. The Semantics can assert rules for how to manage these
            changes. A Semantic defining a value set for data entry might automatically accept any
            deactivations from the source system authority, while a Semantic defining a value set
            for research might automatically decline to adopt deactivations, or do so based on
            whether there are extant operational values. Escalating such decisions for human
            adjudication or review at multiple levels is also always an option. Systems might adopt
            any number of methods for dealing with identified changes: the important thing is to
            ensure the changes can be identified consistently.</para>
    </section>
    <section>
        <title>Field Data Types</title>
        <para> Tinkar supports the following field data types for use with Semantics.<itemizedlist>
                <listitem>
                    <para>String - a sequence of characters, either as a literal constant or as a
                        variable. Strings could be used to represent terms from code systems or
                        things like URLs, textual definitions, etc.</para>
                </listitem>
                <listitem>
                    <para>Integer - data type that represents some range of mathematical
                        integers.</para>
                </listitem>
                <listitem>
                    <para>Float - represents values as high-precision fractional values.</para>
                </listitem>
                <listitem>
                    <para>Boolean - represents the values true and false.</para>
                </listitem>
                <listitem>
                    <para>Byte Array - an array of 8-bit signed two's complement integers.</para>
                </listitem>
                <listitem>
                    <para>Object Array - an array of objects.</para>
                </listitem>
                <listitem>
                    <para>Directed Graph or Digraph - a graph whose edges are ordered pairs of
                        vertices. That is, each edge can be followed from one vertex to another
                        vertex.</para>
                </listitem>
                <listitem>
                    <para>Instant - models a single instantaneous point on a timeline.</para>
                </listitem>
                <listitem>
                    <para>Planar Point - position in a two dimensional space (a plane).</para>
                </listitem>
                <listitem>
                    <para>Spatial Point - position in a three dimensional space.</para>
                </listitem>
                <listitem>
                    <para>Directed Tree or Ditree - a graph obtained from an undirected tree by
                        replacing each undirected edge by two directed edges with opposite
                        directions.</para>
                </listitem>
                <listitem>
                    <para>Vertex - The fundamental unit of data that makes up a graph or
                        tree.</para>
                </listitem>
                <listitem>
                    <para>Component ID List - an ordered list of Component ID's.</para>
                </listitem>
                <listitem>
                    <para>Component ID Set - an unordered list of Component ID's</para>
                </listitem>
            </itemizedlist></para>
    </section>
    <section>
        <title>Type Patterns</title>
        <para>It would be possible to support self-description using the Semantic structure, however
            it would mean associating each definitional assertion with yet another assertion
            characterizing it as definitional. Because this would result in a great deal of
            repetitive information, we have chosen to define another first-class feature of the
            model, the TypePattern (<emphasis role="bold">TypePatternVersion</emphasis> and
                <emphasis role="bold">TypePatternChronology</emphasis>). This feature asserts
            patterns that Semantic components can follow, like an XML or RDF Schema.</para>
        <para>
            <figure>
                <title>Semantic Definition</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Semantic_Definitionv2.png" format="PNG" scalefit="1"
                            width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Semantic Definition</emphasis></para>
                </caption>
            </figure>
        </para>
        <?oxy_comment_start author="timowilliams" timestamp="20210202T170910-0600" comment="inserting an image would be helpful here"?>
        <para>Using this mechanism Semantics of varying structures can be defined using the
            TypePattern. The TypePattern is used to define each field as to what its purpose, data
            type, and meaning. For example, if a field within a semantic is used to describe an
            SDO's website, the Meaning would be "URL, DataType of "String", and Purpose of
            "Website".<?oxy_comment_end?> The TypePattern would then contain an array of these
            FieldDefinitions.</para>
    </section>
    <section>
        <title>Overall Tinkar Architecture</title>
        <para>
            <figure>
                <title>Overall Tinkar Architecture</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Tinkar_Architecturev2.png" format="PNG" scalefit="1" width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Overall Tinkar Architecture</emphasis></para>
                </caption>
            </figure></para>
        <para>Class Definitions: </para>
        <para><emphasis role="bold">Concept</emphasis> - An identifier for a concept or instance.
            The identifier contains no information; all information specifying or describing the
            concept is asserted with Semantics.</para>
        <para><emphasis role="bold">ConceptVersion </emphasis>– A single instance of an identifier
            for a concept with a STAMP. </para>
        <para><emphasis role="bold">ConceptChronology</emphasis> - The set of versions having a
            STAMP for a concept. A concept identifier specifies a ConceptChronology; specifying a
            ConceptVersion requires a rule or parameter for selecting among STAMP values.</para>
        <para><emphasis role="bold">Semantic</emphasis> - A class containing a set of predicates and
            objects about a subject. Semantics perform the descriptive work in Tinkar.</para>
        <para><emphasis role="bold">SemanticVersion</emphasis> - A single instance of an Semantic
            with a STAMP.</para>
        <para><emphasis role="bold">SemanticChronology</emphasis> - The set of versions having a
            STAMP for a Semantic. </para>
        <para><emphasis role="bold">TypePattern</emphasis> - A class defining a set of predicates
            and object types that can be asserted about a class of subjects. All Semantics follow
            Patterns.</para>
        <para><emphasis role="bold">TypePatternVersion</emphasis> - A single instance of a pattern
            with a STAMP.</para>
        <para><emphasis role="bold">TypePatternChronology</emphasis> - The set of versions having a
            STAMP for a pattern. </para>
    </section>
    <section>
        <title>Coordinate</title>
        <para>Tinkar supports and encourages the storage of time series data that utilizes multiple
            dimensions, for example: STAMP, Language, Dialect, clinical domains, etc. The ability to
            efficiently search, display, and navigate concepts and semantics requires the ability to
            calculate combinations of content based on one or more of these different dimensions. </para>
        <para><?oxy_comment_start author="rcholan" timestamp="20210317T164638-0400" comment="Add brief high-level definition/explanation of versioned graphi and how it would be used. "?>A<?oxy_comment_end?>
            versioned graph enables us to recover the state of the graph at a particular point in
            time. Most graph databases do not support versioning as a first-class concept: it is
            possible, however, to create a versioning scheme inside the graph model whereby nodes
            and relationships are timestamped and archived whenever they are modified. The downside
            of such versioning schemes is that they leak into any queries written against the graph,
            adding a layer of complexity to even the simplest query.</para>
        <para>Types of Coordinates:<itemizedlist>
                <listitem>
                    <para>STAMP coordinates are the most basic type of coordinate
                        <?oxy_comment_start author="rcholan" timestamp="20210315T201119-0400" comment="STAMP coordinates are the most basic type of coordinate on which content should be filtered. ?"?>that<?oxy_comment_end?>
                        all content should be filtered. Example of STAMP coordinates are:<itemizedlist>
                            <listitem>
                                <para>most recent version</para>
                            </listitem>
                            <listitem>
                                <para>set of data from several versions</para>
                            </listitem>
                            <listitem>
                                <para>all active components only</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>Language coordinates are used to control the terms that should be
                        displayed. Examples of Language coordinates are:<itemizedlist>
                            <listitem>
                                <para>displaying terms based on a language and/or dialect</para>
                            </listitem>
                            <listitem>
                                <para>prioritized list of synonyms based on a particular clinical
                                    domain</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>Logic coordinates are used to identify the various results from
                        Description Logic Classifiers as well as the different versions of the
                        output over time.</para>
                    <itemizedlist>
                        <listitem>
                            <para>Result from various Description Logic Classifiers</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para>Navigation coordinates are used to assist in the viewing and searching for
                        a particular concept. Examples of these would be:<itemizedlist>
                            <listitem>
                                <para>Stated vs inferred relationships from SNOMED</para>
                            </listitem>
                            <listitem>
                                <para>Concepts inclusion/exclusion for a particular domain</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
            </itemizedlist></para>
        <section>
            <title>Calculating Coordinates</title>
            <para>The ComponentChronology contains all the versions of a component from the date is
                was instantiated until the most recent version. Components only get a new version
                whenever something about the component changes. To calculate the latest version
                requires the ability to find the most recent version of each component. Utilizing
                the STAMP Coordinates supports calculating all other coordinates:</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Identify the Module(s) you would like to view/search/modify.</para>
                    </listitem>
                    <listitem>
                        <para>Identify the Path you would like to view/search/modify.</para>
                    </listitem>
                    <listitem>
                        <para>Identify the Status or Statuses you would like to
                            view/search/modify.</para>
                    </listitem>
                    <listitem>
                        <para>If relevant, identify the Author(s) you would like to
                            view/search/modify.</para>
                    </listitem>
                    <listitem>
                        <para>The last piece of the STAMP coordinate (time) is the most difficult to
                            calculate. In most cases you will need to find the most recent version
                            of the component as of the current time to calculate this point of the
                            coordinate. However, since Tinkar supports and encourages the
                            representation of historical, you may need to calculate the most recent
                            version as of a different point in time. </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>After the STAMP Coordinates have been calculated, additional coordinates can then
                be applied as well. For example, applying a language and dialect coordinate will be
                important not only for viewing and searching, but also to determine the appropriate
                preferred name for displaying a hierarchy.</para>
        </section>
    </section>
</chapter>
