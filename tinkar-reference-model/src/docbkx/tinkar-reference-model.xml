<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../../../docbook-customization/src/docbkx-stylesheet/common/komet.rnc" type="application/relax-ng-compact-syntax"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <title>Tinkar Reference Model</title>
    <para>This section describes classes of objects that support a common foundational framework for
        <?oxy_comment_start author="timowilliams" timestamp="20210120T141743-0600" comment="Could this support non-standards based terminology as well?  Should we just drop this?"?>standards-based<?oxy_comment_end?>
        terminology and knowledge base systems (e.g. SNOMED CT, LOINC, RxNorm, HL7, etc.). </para>
    <para> </para>
    <section>
        <title>Model Representation</title>
        <para>The Tinkar Reference Model is a logical model described herein using the Object
            Management Group (OMG) Unified Modeling Language (UML) 2.0 notation to describe the
            structure of integrated data representation and change management for biomedical
            terminologies. </para>
    </section>
    <section>
        <title>Standard Class Model</title>
        <para>
            <figure>
            <title>Versioned Component</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Versioned_Component.png" scalefit="1" width="100%" contentdepth="100%"/>
                </imageobject>
            </mediaobject>
            <caption>
                    <para><emphasis role="italics">Versioned Component</emphasis>
                    </para>
                </caption>
            </figure>
        </para>
        <para>The Tinkar Reference Model fulfills the requirement of capturing a complete record of
            all changes, including relevant context information
            (<?oxy_comment_start author="timowilliams" timestamp="20210218T094737-0600" comment="Add links back to the requirement chapter for each of these"?>Requirement
            18<?oxy_comment_end?>): </para>
        <para>
            <orderedlist>
                <listitem>
                    <para><emphasis role="bold">Status of the component:</emphasis> A status is
                        identified by a concept, which may be annotated with other identifying
                        information. For example: active or inactive (Requirement 20)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Time of change:</emphasis> Timestamps must employ a
                        common standard, which must support precision and time zone. (Requirement
                        21)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Author of change:</emphasis> An author is identified
                        by a concept, which may be annotated with other identifying information.
                        (Requirement 22)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Module: </emphasis>Assignment to the appropriate
                        terminology (e.g., LOINC) or terminology component (e.g., SNOMED CT, US
                        Extension). A module is identified by a concept, which may be annotated with
                        other identifying information. (Requirement 23) </para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Path:</emphasis> Specification of a branch within a
                        terminology development lifecycle, e.g., for distributed development,
                        testing, staging, or production. A path is identified by a concept, which
                        may be annotated with other identifying information. A core set of paths is
                        necessary to support publication to external organizations. (Requirement
                        24)</para>
                </listitem>
            </orderedlist>
        </para>
                    <para>These elements together are referred to by the acronym “<emphasis
                role="bold">STAMP</emphasis>”. Every new assertion, whether a new component or a
            change to an existing component, must have a STAMP in order to determine when it is to
            be used. The STAMP properties support the ability to apply terminology components for
            specific purposes. For example, <itemizedlist>
                <listitem>
                    <para>“Path” can be used to test provisional content without physically swapping
                        out systems.</para>
                </listitem>
                <listitem>
                    <para>“Module” can be used to filter out work that has not been authorized by
                        the enterprise.</para>
                </listitem>
                <listitem>
                    <para>“Time” supports the ability to apply CDS rules as they would have looked
                        in the past. </para>
                </listitem>
            </itemizedlist>The Tinkar model does not merely support the ability to “STAMP”
            components: it asserts a requirement that all changes be STAMPed. STAMP assertions are
            unversioned IdentifiedComponents that are referenced by the components they scope. Since
            STAMP uses versioned (and STAMPED) concepts, having the STAMP as a versioned component
            would lead to an infinite regress. </para>
        <para>All IdentifedComponents in the knowledge base will consist of a series of change
            records, called ComponentVersions, (beginning with the “Create” version), all associated
            to an underlying ComponentChronology.</para>
        <figure>
            <title>A “Chronology” Instance view</title>
            <mediaobject>
                <imageobject>
                    <?oxy_comment_start author="timowilliams" timestamp="20210218T105212-0600" comment="Need new image removing the ImmutableList"?>
                    <imagedata fileref="clip_image004_88487584.png" scalefit="1" width="100%"
                        contentdepth="100%"/><?oxy_comment_end?>
                </imageobject>
            </mediaobject>
            <caption>
                <para><emphasis role="italics">A “Chronology” Instance view</emphasis></para>
            </caption>
        </figure>
        <para>A Components Chronology only has properties inasmuch as they are attributed to it by
            its versions. Looking at the IdentifiedComponent through different sets of changes
            (published version, geographically defined set of modules, historical timestamp) may
            reveal substantially different IdentifedComponents. </para>
    </section>
    <section>
        <title>Component Types</title>
        <para>Requirement 19 states that the design must support all known and unknown properties,
            so it must be a meta-model. In addition, components must be identifiable. </para>
        <para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="clip_image008_1535615720.png" scalefit="1" width="100%"
                        contentdepth="100%"/>
                </imageobject>
            </mediaobject>
        </para>
        <para>Both Concepts and the Semantics that describe them are uniquely identified using
            UUIDs.  To assemble groups of assertions and to provide information about Concepts,
            Tinkar uses a construct called a <emphasis role="bold">Semantic</emphasis>. A Semantic
            is a collection of values that supports the specification of value sets, compositional
            definitions, and other components requiring internal structure, and it specifies the
            nature of the compositional relationship explicitly. </para>
        <para>The Semantic uses a Concept to define the relationship between the value(s) and the
            Concept; the value itself may be either a concept or some other kind of data type, such
            as a string. We then create the ability to assemble assertions into more complex
            structures. <figure>
                <title>Compositional Semantics</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Compositional_Semantics.png" format="PNG" scalefit="1"
                            width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Compositional Semantics</emphasis></para>
                </caption>
            </figure></para>
        <para>As discussed earlier, if an author makes a change to an IdentifiedComponent, the prior
            Version is unchanged, but a new version – with the appropriate STAMP information – is
            recorded. Users viewing the Concept and associated Semantics in the prior context (i.e.,
            as of the prior time, if no other STAMP element has changed) will see the old values;
            users viewing the Concept and associated Semantics in the new context will see the new
            values.</para>
        <para>Since it is versioned, a Semantic is manifest as a <emphasis role="bold"
                >SemanticChronology</emphasis>, containing a set of <emphasis role="bold"
                >SemanticVersions</emphasis>. Concepts, too, are manifest as collections: a
                <emphasis role="bold">ConceptChronology</emphasis> consisting of a set of <emphasis
                role="bold">ConceptVersions</emphasis>.</para>
        <para>If other IdentifiedComponents depend on the changed concept, they can be identified by
            relationships in the Semantics. The Semantics can assert rules for how to manage these
            changes. A Semantic defining a value set for data entry might automatically accept any
            deactivations from the source system authority, while a Semantic defining a value set
            for research might automatically decline to adopt deactivations, or do so based on
            whether there are extant operational values. Escalating such decisions for human
            adjudication or review at multiple levels is also always an option. Systems might adopt
            any number of methods for dealing with identified changes: the important thing is to
            ensure the changes can be identified consistently.</para>
    </section>
    <section>
        <title>Data Types</title>
        <para> Tinkar supports the following field data types for use with Semantics.<itemizedlist>
                <listitem>
                    <para>String - a sequence of characters, either as a literal constant or as some
                        kind of variable. Strings could be used to represent terms from code systems
                        or things like URLs, textual definitions, etc.</para>
                </listitem>
                <listitem>
                    <para>Integer - data type that represents some range of mathematical
                        integers.</para>
                </listitem>
                <listitem>
                    <para>Float - represents values as high-precision fractional values</para>
                </listitem>
                <listitem>
                    <para>Boolean - represents the values true and false.</para>
                </listitem>
                <listitem>
                    <para>Byte Array - an array of 8-bit signed two's complement integers</para>
                </listitem>
                <listitem>
                    <para>Object Array - an array of objects</para>
                </listitem>
                <listitem>
                    <para>Directed Graph or Digraph - A graph whose edges are ordered pairs of
                        vertices. That is, each edge can be followed from one vertex to another
                        vertex.</para>
                </listitem>
                <listitem>
                    <para>Instant - models a single instantaneous point on the time-line.</para>
                </listitem>
                <listitem>
                    <para>Planar Point - </para>
                </listitem>
                <listitem>
                    <para>Spatial Point -</para>
                </listitem>
                <listitem>
                    <para>Ditree - </para>
                </listitem>
                <listitem>
                    <para>Vertex - </para>
                </listitem>
            </itemizedlist>
        </para>
        <?oxy_comment_start author="timowilliams" timestamp="20210218T185928-0600" comment="Where do these fit into the model?"?>
        <para>Mentioned, but exist elsewhere: <itemizedlist>
                <listitem>
                    <para>COMPONENT_ID_LIST</para>
                </listitem>
                <listitem>
                    <para>COMPONENT_ID_SET<?oxy_comment_end?></para>
                </listitem>
            </itemizedlist>
        </para>
    </section>
    <section>
        <title>Patterns for Semantic</title>
        <para>It would be possible to support self-description using the Semantic structure, however
            it would mean associating each definitional assertion with yet another assertion
            characterizing it as definitional. Because this would result in a great deal of
            repetitive information, we have chosen to define another first-class feature of the
            model, the PatternForSemantic (<emphasis role="bold"
                >PatternForSemanticVersion</emphasis> and <emphasis role="bold"
                >PatternForSemanticChronology</emphasis>). This feature asserts patterns that
            Semantic components can follow, similar to an XML or RDF Schema.</para>
        <para>
            <figure>
                <title>Semantic Definition</title>
                <mediaobject>
                    <imageobject>
                        <?oxy_comment_start author="timowilliams" timestamp="20210218T215307-0600" comment="I think we need to update the Field Definition to have a field for Meaning, Datatype, and purpose"?>
                        <imagedata fileref="Semantic_Definition.png" format="PNG" scalefit="1"
                            width="100%" contentdepth="100%"/><?oxy_comment_end?>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Semantic Definition</emphasis></para>
                </caption>
            </figure>
        </para>
        <?oxy_comment_start author="timowilliams" timestamp="20210202T170910-0600" comment="inserting an image would be helpful here"?>
        <para>Using this mechanism Semantics of varying structures can be defined using the
            PatternForSemantic. The PatternForSemantic is used to define each field as to what its
            purpose, data type, and meaning. For example, if a field within a semantic is used to
            describe an SDO's website, the Meaning would be "URL, DataType of "String", and Purpose
            of "Website".<?oxy_comment_end?></para>
    </section>
    <section>
        <title/>
        <para>
            <figure>
                <title>Overall Tinkar Architecture</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Tinkar_Architecture.png" format="PNG" scalefit="1" width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Overall Tinkar Architecture</emphasis></para>
                </caption>
            </figure></para>
    </section>
    <section>
        <title>Constraints</title>
        <para>Constraints are required to:<itemizedlist>
                <listitem>
                    <para>ensure that the appropriate level of detail for standard terminologies are
                        represented within Tinkar</para>
                </listitem>
                <listitem>
                    <para>if extensions are created that they conform to the requirements of the
                        standard(s) they are based upon</para>
                </listitem>
                <listitem>
                    <para>perform general quality assurance</para>
                </listitem>
            </itemizedlist>For example, constraints would be used to represent standard terminology
            artifacts like the SNOMED CT Machine Readable Concept Model. Additionally, constraints
            could be used to ensure that terminologies are represented within Tinkar in such a way
            that they can be completely and consistently queried and displayed. </para>
        <para>These same constraints can be used with respect to creating new content within Tinkar
            to specify what the minimally viable data that would be required. For example:<itemizedlist>
                <listitem>
                    <para>All concepts must have at least one Fully Qualified Name within at least
                        one Language or Dialect.</para>
                </listitem>
                <listitem>
                    <para>All concepts must have at least one Name specified as Preferred within at
                        least one Language or Dialect.</para>
                </listitem>
                <listitem>
                    <para>All concepts must have at least one parent, unless it is a root
                        concept.</para>
                </listitem>
            </itemizedlist></para>
        <para>Constraints can be applied (and not applied) based on various criteria to perform
            Quality Assurance on content that is represented within Tinkar. For example:<itemizedlist>
                <listitem>
                    <para>SNOMED CT FullySpecifiedName hierarchy tags are applied based on where a
                        concept exists in a hierarchy</para>
                </listitem>
                <listitem>
                    <para>Relationships between concepts have domain (based on hierarchy) and range
                        (the hierarchy(s) of values that a relationship takes)</para>
                </listitem>
                <listitem>
                    <para>Modeling templates can be specified to ensure that new content that is
                        created under a certain node in a hierarchy uses similar wording and
                        relationships.</para>
                </listitem>
            </itemizedlist></para>
        <para>Since some Quality Assurance Constraints do not always indicate an error an Allow List
            could also be represented as a Semantic to record concepts that are allowed not to
            conform to a constraint. Constraints would be represented using semantics as they are
            self describing and can support multiple different representations for constraints
            (SNOMED CT Expression Constraint Language, Drools, etc.). Representing Constraints as a
            Semantic also ensures they have a STAMP so they are versioned over time, captures author
            information and allows them to be tested and progressed over different modules and
            paths.</para>
        <para>Implementing Constraints would depend upon how the Constraints are written and
            formatted. For example, Implementers could utilize a Rete algorithm through something
            like Drools to implement Constraints.</para>
    </section>
    <section>
        <title>Coordinate</title>
        <para>Tinkar supports and encourages the storage of time series data that utilizes multiple
            dimensions, for example: STAMP, Language, Dialect, clinical domains, etc. The ability to
            efficiently search, display, and navigate concepts and semantics requires the ability to
            calculate particular combinations of content based on one or more of these different
            dimensions. </para>
        <para>Types of Coordinates:<itemizedlist>
                <listitem>
                    <para>STAMP coordinates are the most basic type of coordinate that all content
                        should be filtered.  Example of STAMP coordinates are:<itemizedlist>
                            <listitem>
                                <para>most recent version</para>
                            </listitem>
                            <listitem>
                                <para>set of data from several versions</para>
                            </listitem>
                            <listitem>
                                <para>all active components only</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>Language coordinates are used to control the terms that should be
                        displayed.  Examples of Language coordinates are:<itemizedlist>
                            <listitem>
                                <para>displaying terms based on a language and/or dialect</para>
                            </listitem>
                            <listitem>
                                <para>prioritized list of synonyms based on a particular clinical
                                    domain</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>Logic coordinates are used to identify the various results from
                        Description Logic Classifiers as well as the different versions of the
                        output over time.</para>
                    <itemizedlist>
                        <listitem>
                            <para>Result from various Description Logic Classifiers</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para>Navigation coordinates are used <itemizedlist>
                            <listitem>
                                <para>Stated vs inferred relationships from SNOMED</para>
                            </listitem>
                            <listitem>
                                <para>Concepts inclusion/exclusion for a particular domain</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
            </itemizedlist></para>
        <para>Define data for coordinates</para>
        <para>Define behavior of coordinates</para>
        <para>
            <figure>
                <title>A “latest” Instance view</title>
                <mediaobject>
                    <imageobject>
                        <?oxy_comment_start author="timowilliams" timestamp="20210126T130544-0600" comment="I don&apos;t see this table in the overall architecture?  Is this just a view we are calculating?  "?>
                        <imagedata fileref="clip_image006_1731007892.png"  scalefit="1" width="100%" contentdepth="100%"/><?oxy_comment_end?>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">A “latest” Instance view</emphasis></para>
                    <para>The ComponentChronology contains all the versions of a component from the
                        date is was instantiated until the most recent version. Components only get
                        a new version whenever something about the component changes.  To calculate
                        the latest version requires the ability to find the most recent version of
                        each component.</para>
                </caption>
            </figure>
        </para>
    </section>
    

</chapter>
