<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../../../docbook-customization/src/docbkx-stylesheet/common/komet.rnc" type="application/relax-ng-compact-syntax"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <title>Tinkar Reference Model</title>
    <para>This section describes classes of objects that support a common foundational framework for
        <?oxy_comment_start author="timowilliams" timestamp="20210120T141743-0600" comment="Could this support non-standards based terminology as well?  Should we just drop this?"?>standards-based<?oxy_comment_end?>
        terminology and knowledge base systems (e.g. SNOMED CT, LOINC, RxNorm, HL7, etc.). </para>
    <para> </para>
    <section>
        <title>Model Representation</title>
        <para>The Tinkar Referene Model is a logical model described herein using the Object
            Management Group (OMG) Unified Modeling Language (UML) 2.0 notation to describe the
            structure of integrated data representation and change management for biomedical
            terminologies. </para>
    </section>
    <section>
        <title>Standard Class Model</title>
        <para>
            <figure>
            <title>Versioned Component</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Versioned_Component.png" scalefit="1" width="100%" contentdepth="100%"/>
                </imageobject>
            </mediaobject>
            <caption>
                    <para><emphasis role="italics">Versioned Component</emphasis>
                    </para>
                </caption>
            </figure>
        </para>
        <para>The Tinkar Reference Model fulfills the requirement of capturing a complete record of
            all changes, including relevant context information (Requirement 18): </para>
        <para>
            <orderedlist>
                <listitem>
                    <para><emphasis role="bold">Status of the component:</emphasis> A status is
                        identified by a concept, which may be annotated with other identifying
                        information. For example: active or inactive (Requirement 20) </para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Time of change:</emphasis> Timestamps must employ a
                        common standard, which must support precision and time zone. (Requirement
                        21) </para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Author of change:</emphasis> An author is identified
                        by a concept, which may be annotated with other identifying information.
                        (Requirement 22) </para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Module: </emphasis>Assignment to the appropriate
                        terminology (e.g., LOINC) or terminology component (e.g., SNOMED CT, US
                        Extension). A module is identified by a concept, which may be annotated with
                        other identifying information. All modules must have a defined relationship
                        to the root module. (Requirement 23) </para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Path:</emphasis> Specification of a branch within an
                        organization, e.g., for distributed development, testing, staging, or
                        production. A path is identified by a concept, which may be annotated with
                        other identifying information. A core set of paths is necessary to support
                        publication to external organizations. (Requirement 24)</para>
                </listitem>
            </orderedlist>
        </para>
                    <para>These elements together are referred to by the acronym “STAMP.” Every new
            assertion, whether a new component or a change to an existing component, must have a
            STAMP in order to determine when it is to be used. The STAMP properties support the
            ability to apply terminology components for specific purposes. For example, <itemizedlist>
                <listitem>
                    <para>“Path” can be used to test provisional content without physically swapping
                        out systems.</para>
                </listitem>
                <listitem>
                    <para>“Module” can be used to filter out work that has not been authorized be
                        the enterprise.</para>
                </listitem>
                <listitem>
                    <para>“Time” supports the ability to apply CDS rules as they would have looked
                        in the past. </para>
                </listitem>
            </itemizedlist>The Tinkar model does not merely support the ability to “STAMP”
            assertions: it asserts a requirement that all changes be STAMPed. STAMP assertions are
            unversioned IdentifiedComponents to avoid the need to repeat the STAMP for all other
            IdentifiedComponents. As a result, any IdentifedComponent in the knowledge base will
            consist of a series of change records, called ComponentVersions, (beginning with the
            “Create” version), all associated to an underlying ComponentChronology.</para>
        <figure>
            <title>A “Chronology” Instance view</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="clip_image004_88487584.png" scalefit="1" width="100%" contentdepth="100%"/>
                </imageobject>
            </mediaobject>
            <caption>
                <para><emphasis role="italics">A “Chronology” Instance view</emphasis></para>
                <para>A components Chronology only has properties inasmuch as they are attributed to
                    it by its versions. Looking at the IdentifedComponent through different sets of
                    changes (published version, geographically defined set of modules, historical
                    timestamp) may reveal substantially different IdentifedComponents. </para>
            </caption>
        </figure>
    </section>
    <section>
        <title>Component Types</title>
        <para>Requirement 19 states that the design must support all known and unknown properties,
            so it must be a meta-model. In addition, components must be identifiable. The result is
            similar to RDF with the addition of identification:</para>
        <para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="clip_image008_1535615720.png" scalefit="1" width="100%"
                        contentdepth="100%"/>
                </imageobject>
            </mediaobject>
        </para>
        <para>To assemble groups of assertions, Tinkar uses a construct called a <emphasis
                role="bold">Semantic</emphasis>, which is an Identified Component. A Semantic is a
            collection of values that supports the specification of value sets, compositional
            definitions, and other components requiring internal structure, and it specifies the
            nature of the compositional relationship explicitly. Since it is versioned, a Semantic
            is manifest as a <emphasis role="bold">SemanticChronology</emphasis>, containing a set
            of <emphasis role="bold">SemanticVersions</emphasis>. Concepts, too, are manifest as
            collections: a <emphasis role="bold">ConceptChronology</emphasis> consisting of a set of
                <emphasis role="bold">ConceptVersions</emphasis>.</para>
        <figure>
            <title>Compositional Semantics</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Compositional_Semantics.png" format="PNG" scalefit="1"
                        width="100%" contentdepth="100%"/>
                </imageobject>
            </mediaobject>
            <caption>
                <para><emphasis role="italics">Compositional Semantics</emphasis></para>
            </caption>
        </figure>
        <para>Both Concepts and the Semantics that describe them are uniquely identified using
            UUID's. The Semantic uses a Concept to define the relationship between the value(s) and
            the Concept; the value itself may be either a concept or some other kind of value, such
            as a string. We then create the ability to assemble assertions into more complex
            structures. </para>
        <?oxy_comment_start author="timowilliams" timestamp="20210202T165204-0600" comment="Since concepts contain very little information they shouldn&apos;t have many versions.  If a semantic that is attached to a concept changes, the concept itself doesn&apos;t change.  Correct?"?>
        <para>As discussed earlier, if an author makes a change to a concept, the prior Version is
            unchanged, but a new version – with the appropriate STAMP information – is recorded.
            Users viewing the concept in the prior context (i.e., as of the prior time, if no other
            STAMP element has changed) will see the old value; users viewing the concept in the new
            context will see the new value.<?oxy_comment_end?></para>
        <para>If other IdentifiedComponents depend on the changed concept, they can be identified by
            relationships in the Semantics. The Semantics can assert rules for how to manage these
            changes. A Semantic defining a value set for data entry might automatically accept any
            deactivations from the source system authority, while a Semantic defining a value set
            for research might automatically decline to adopt deactivations, or do so based on
            whether there are extant operational values. Escalating such decisions for human
            adjudication or review at multiple levels is also always an option. Systems might adopt
            any number of methods for dealing with identified changes: the important thing is to
            ensure the changes can be identified consistently.</para>
    </section>
    <section>
        <title>Patterns for Semantic</title>
        <para>It would be possible to support self-description using the Semantic structure, however
            it would mean associating each definitional assertion with yet another assertion
            characterizing it as definitional. Because this would result in a great deal of
            repetitive information, we have chosen to define another first-class feature of the
            model, the PatternForSemantic (<emphasis role="bold"
                >PatternForSemanticVersion</emphasis> and <emphasis role="bold"
                >PatternForSemanticChronology</emphasis>). This feature uses a similar mechanism to
            assert patterns that Semantic component can follow, just like an XML or RDF
            Schema.</para>
        <para>
            <figure>
                <title>Semantic Definition</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Semantic_Definition.png" format="PNG" scalefit="1"
                            width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Semantic Definition</emphasis></para>
                </caption>
            </figure>
        </para>
        <?oxy_comment_start author="timowilliams" timestamp="20210202T170910-0600" comment="inserting an image would be helpful here"?>
        <para>Using this mechanism Semantics of varying structures can be defined using the
            PatternForSemantic.  The PatternForSemantic is used to define each field as to what its
            purpose, data type, and meaning.  For example, if a field within a semantic is used to
            descibe an SDO's website, the Meaning would be "URL, DataType of "String", and Purpose
            of "Website".<?oxy_comment_end?></para>
    </section>
    <section>
        <title/>
        <para>
            <figure>
                <title>Overall Tinkar Architecture</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Tinkar_Architecture.png" format="PNG" scalefit="1" width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Overall Tinkar Architecture</emphasis></para>
                </caption>
            </figure></para>
    </section>
    <section>
        <title>Constraints</title>
        <para>Constraints are required to:<itemizedlist>
                <listitem>
                    <para>ensure that the appropriate level of detail for standard terminologies are
                        represented within Tinkar</para>
                </listitem>
                <listitem>
                    <para>if extensions are created that they conform to the requirements of the
                        standard(s) they are based upon</para>
                </listitem>
                <listitem>
                    <para>perform general quality assurance</para>
                </listitem>
            </itemizedlist>For example, constraints would be used to represent standard terminology
            artifacts like the SNOMED CT Machine Readable Concept Model. Additionally, constraints
            could be used to ensure that terminologies are represented within Tinkar in such a way
            that they can be completely and consistently queried and displayed. </para>
        <para>These same constraints can be used with respect to creating new content within Tinkar
            to specify what the minimally viable data that would be required. For example:<itemizedlist>
                <listitem>
                    <para>All concepts must have at least one Fully Qualified Name within at least
                        one Language or Dialect.</para>
                </listitem>
                <listitem>
                    <para>All concepts must have at least one Name specified as Preferred within at
                        least one Language or Dialect.</para>
                </listitem>
                <listitem>
                    <para>All concepts must have at least one parent, unless it is a root
                        concept.</para>
                </listitem>
            </itemizedlist></para>
        <para>Constraints can be applied (and not applied) based on various criteria to perform
            Quality Assurance on content that is represented within Tinkar. For example:<itemizedlist>
                <listitem>
                    <para>SNOMED CT FullySpecifiedName hierarchy tags are applied based on where a
                        concept exists in a hierarchy</para>
                </listitem>
                <listitem>
                    <para>Relationships between concepts have domain (based on hierarchy) and range
                        (the hieararchy(s) of values that a relationship takes)</para>
                </listitem>
                <listitem>
                    <para>Modeling templates can be specified to ensure that new content that is
                        created under a certain node in a hierarchy uses similar wording and
                        relationships.</para>
                </listitem>
            </itemizedlist></para>
        <para>Since some Quality Assurance Constraints do not always indicate an error an Allow List
            could also be represented as a Semantic to record concepts that are allowed not to
            conform to a constraint. Constraints would be represented using semantics as they are
            self describing and can support multiple different representations for constraints
            (SNOMED CT Expression Constraint Language, Drools, etc.). Representing Constraints as a
            Semantic also ensures they have a STAMP so they are versioned over time, captures author
            information and allows them to be tested and progressed over different modules and
            paths.</para>
        <para>Implementing Constaints would depend upon how the Constraints are written and
            formatted. For example, Implementers could utilize a Rete algorithm through something
            like Drools to implement Constraints.</para>
    </section>
    <section>
        <title>Coordinate</title>
        <para>Tinkar supports and encourages the storage of time series data that utilizes multiple
            dimensions, for example: STAMP, source or content [SNOMED,LOINC,RxNORM, etc], Language,
            Dialect, clinical domains. The ability to efficiently search, display, and navigate
            concepts and semantics requires the ability to calculate particular combinations of
            content based on one or more of these different dimensions.  </para>
        <para>Types of Coordinates:<itemizedlist>
                <listitem>
                    <para>STAMP coordinates are the most basic type of coordinate that all content
                        should be filtered.  Example of STAMP coordinates are:<itemizedlist>
                            <listitem>
                                <para>most recent version</para>
                            </listitem>
                            <listitem>
                                <para>set of data from several versions</para>
                            </listitem>
                            <listitem>
                                <para>all active components only</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>Language coordinates are used to control the terms that should be
                        displayed.  Examples of Language coordinates are:<itemizedlist>
                            <listitem>
                                <para>displaying terms based on a language and/or dialect</para>
                            </listitem>
                            <listitem>
                                <para>prioritized list of synonyms based on a particular clinical
                                    domain</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>Logic coordinates are used to identify the various results from
                        Description Logic Classifiers as well as the different versions of the
                        output over time.</para>
                    <itemizedlist>
                        <listitem>
                            <para>Result from various Description Logic Classifiers</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para>Navigation coordinates are used <itemizedlist>
                            <listitem>
                                <para>Stated vs inferred relationships from SNOMED</para>
                            </listitem>
                            <listitem>
                                <para>Concepts inclusion/exclusion for a particular domain</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
            </itemizedlist></para>
        <para>Define data for coordinates</para>
        <para>Define behaviour of coordinates</para>
        <para>
            <figure>
                <title>A “latest” Instance view</title>
                <mediaobject>
                    <imageobject>
                        <?oxy_comment_start author="timowilliams" timestamp="20210126T130544-0600" comment="I don&apos;t see this table in the overall architecture?  Is this just a view we are calculating?  "?>
                        <imagedata fileref="clip_image006_1731007892.png"  scalefit="1" width="100%" contentdepth="100%"/><?oxy_comment_end?>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">A “latest” Instance view</emphasis></para>
                    <para>The ComponentChronology contains all the versions of a component from the
                        date is was instantiated until the most recent version. Components only get
                        a new version whenever something about the component changes.  To calculate
                        the latest version requires the ability to find the most recent version of
                        each component.</para>
                </caption>
            </figure>
        </para>
    </section>
    

</chapter>
