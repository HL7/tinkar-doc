<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../../../docbook-customization/src/docbkx-stylesheet/common/komet.rnc" type="application/relax-ng-compact-syntax"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <title>Tinkar Reference Model</title>
    <para>This section describes classes of objects that support a common foundational framework for
        terminology and knowledge base systems (e.g. SNOMED CT, LOINC, RxNorm, HL7, etc.). </para>
    <para> Model Representation</para>
   
        <para>The Tinkar Reference Model is a logical model described herein using the Object
            Management Group (OMG) Unified Modeling Language (UML) 2.0 notation to describe the
            structure of integrated data representation and change management for biomedical
            terminologies. </para>
    
    <section>
        <title>Standard Class Model</title>
        <para>
            <figure>
            <title>Versioned Component</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Versioned_Component.png" scalefit="1" width="100%" contentdepth="100%"/>
                </imageobject>
            </mediaobject>
            <caption>
                    <para><emphasis role="italics">Versioned Component</emphasis>
                    </para>
                </caption>
            </figure>
        </para>
        <para>The Tinkar Reference Model fulfills the requirement of capturing a complete record of
            all changes, including relevant context information
            (<?oxy_comment_start author="timowilliams" timestamp="20210218T094737-0600" comment="Add links back to the requirement chapter for each of these"?>Requirement
            18<?oxy_comment_end?>).  This is captured via the STAMP class using the following
            fields: </para>
        <para>
            <orderedlist>
                <listitem>
                    <para><emphasis role="bold">Status:</emphasis> A status is identified by a
                        concept, which may be annotated with other identifying information. For
                        example: active or inactive (Requirement 20)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Time:</emphasis> Timestamps must employ a common
                        standard, which must support precision and time zone. (Requirement
                        21)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Author:</emphasis> An author is identified by a
                        concept, which may be annotated with other identifying information as
                        required. (Requirement 22)</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Module: </emphasis>Assignment to the appropriate
                        terminology (e.g., LOINC) or terminology component (e.g., SNOMED CT, US
                        Extension). A module is identified by a concept, which may be annotated with
                        other identifying information. (Requirement 23) </para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Path:</emphasis> Specification of a branch within a
                        terminology development lifecycle, e.g., for distributed development,
                        testing, staging, or production. A path is identified by a concept, which
                        may be annotated with other identifying information. A core set of paths is
                        necessary to support publication to external organizations. (Requirement
                        24)</para>
                </listitem>
            </orderedlist>
        </para>
                    <para>These elements together are referred to by the acronym “<emphasis
                role="bold">STAMP</emphasis>”. Every new assertion, whether a new component or a
            change to an existing component, must have a STAMP in order to determine when it is to
            be used. The STAMP properties support the ability to apply terminology components for
            specific purposes. For example, <itemizedlist>
                <listitem>
                    <para>“Path” can be used to test provisional content without physically swapping
                        out systems.</para>
                </listitem>
                <listitem>
                    <para>“Module” can be used to filter out work that has not been authorized by
                        the enterprise.</para>
                </listitem>
                <listitem>
                    <para>“Time” supports the ability to apply CDS rules as they would have looked
                        in the past. </para>
                </listitem>
            </itemizedlist>The Tinkar model does not merely support the ability to “STAMP”
            components: it asserts a requirement that all changes be STAMPed. STAMP assertions are
            unversioned IdentifiedComponents that are referenced by the components they scope. Since
            STAMP uses versioned (and STAMPED) concepts, having the STAMP as a versioned component
            would lead to an infinite regress. </para>
        <para>All IdentifedComponents in the knowledge base will consist of a series of change
            records, called ComponentVersions, (beginning with the “Create” version), all associated
            to an underlying ComponentChronology.</para>
        
        <para>A Components Chronology only has properties inasmuch as they are attributed to it by
            its versions. Looking at the IdentifiedComponent through different sets of changes
            (published version, geographically defined set of modules, historical timestamp) may
            reveal substantially different IdentifedComponents. </para>
    </section>
    <section>
        <title>Component Types</title>
        <para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Identified_Components.png" scalefit="1" width="100%"
                        contentdepth="100%"/>
                </imageobject>
            </mediaobject>
        </para>
        <para>All Components in Tinkar are uniquely identified using UUIDs. A Component will be
            represented by an array of UUID's with at least one UUID, but can be represented by more
            than one UUID in the case of a concept being derived from multiple sources. For example,
            the concept Acetaminophen (which exists in SNOMED, LOINC, and RxNorm) would have a UUID
            from each terminology and be represented as an array of UUID's for this single concept
            within a TINKAR implementation. </para>
        <para>To assemble groups of assertions and to provide information about Concepts, Tinkar
            uses a construct called a <emphasis role="bold">Semantic</emphasis>. A Semantic is a
            collection of values that supports the specification of value sets, compositional
            definitions, and other components requiring internal structure, and it specifies the
            nature of the compositional relationship explicitly. </para>
        <para>The Semantic class uses a Concept to define the relationship between the value(s) and
            the Concept; the value itself may be either a concept or some other kind of data type,
            such as a string. We then create the ability to assemble assertions into more complex
            structures. <figure>
                <title>Compositional Semantics</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Compositional_Semantics.png" format="PNG" scalefit="1"
                            width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Compositional Semantics</emphasis></para>
                </caption>
            </figure></para>
        <para>As discussed earlier, if an author makes a change to an IdentifiedComponent, the prior
            Version is unchanged, but a new version – with the appropriate STAMP information – is
            recorded. Users viewing the Concept and associated Semantics in the prior context (i.e.,
            as of the prior time, if no other STAMP element has changed) will see the old values;
            users viewing the Concept and associated Semantics in the new context will see the new
            values.</para>
        <para>Since it is versioned, a Semantic is manifest as a <emphasis role="bold"
                >SemanticChronology</emphasis>, containing a set of <emphasis role="bold"
                >SemanticVersions</emphasis>. Concepts, too, are manifest as collections: a
                <emphasis role="bold">ConceptChronology</emphasis> consisting of a set of <emphasis
                role="bold">ConceptVersions</emphasis>.</para>
        <para>If other IdentifiedComponents depend on the changed concept, they can be identified by
            relationships in the Semantics. The Semantics can assert rules for how to manage these
            changes. A Semantic defining a value set for data entry might automatically accept any
            deactivations from the source system authority, while a Semantic defining a value set
            for research might automatically decline to adopt deactivations, or do so based on
            whether there are extant operational values. Escalating such decisions for human
            adjudication or review at multiple levels is also always an option. Systems might adopt
            any number of methods for dealing with identified changes: the important thing is to
            ensure the changes can be identified consistently.</para>
    </section>
    <section>
        <title>Field Data Types</title>
        <para> Tinkar supports the following field data types for use with Semantics.<itemizedlist>
                <listitem>
                    <para>String - a sequence of characters, either as a literal constant or as some
                        kind of variable. Strings could be used to represent terms from code systems
                        or things like URLs, textual definitions, etc.</para>
                </listitem>
                <listitem>
                    <para>Integer - data type that represents some range of mathematical
                        integers.</para>
                </listitem>
                <listitem>
                    <para>Float - represents values as high-precision fractional values</para>
                </listitem>
                <listitem>
                    <para>Boolean - represents the values true and false.</para>
                </listitem>
                <listitem>
                    <para>Byte Array - an array of 8-bit signed two's complement integers</para>
                </listitem>
                <listitem>
                    <para>Object Array - an array of objects</para>
                </listitem>
                <listitem>
                    <para>Directed Graph or Digraph - a graph whose edges are ordered pairs of
                        vertices. That is, each edge can be followed from one vertex to another
                        vertex.</para>
                </listitem>
                <listitem>
                    <para>Instant - models a single instantaneous point on a timeline.</para>
                </listitem>
                <listitem>
                    <para>Planar Point - </para>
                </listitem>
                <listitem>
                    <para>Spatial Point -</para>
                </listitem>
                <listitem>
                    <para>Directed Tree or Ditree - a graph obtained from an undirected tree by
                        replacing each undirected edge by two directed edges with opposite
                        directions.</para>
                </listitem>
                <listitem>
                    <para>Vertex - The fundamental unit of data that makes up a graph or
                        tree.</para>
                </listitem>
            <listitem>
                <para>Component ID List - an ordered list of Component ID's</para>
            </listitem>
            <listitem>
                <para>Component ID Set - an unordered list of Component ID's</para>
            </listitem>
            </itemizedlist>
        </para>
    </section>
    <section>
        <title>Patterns for Semantic</title>
        <para>It would be possible to support self-description using the Semantic structure, however
            it would mean associating each definitional assertion with yet another assertion
            characterizing it as definitional. Because this would result in a great deal of
            repetitive information, we have chosen to define another first-class feature of the
            model, the PatternForSemantic (<emphasis role="bold"
                >PatternForSemanticVersion</emphasis> and <emphasis role="bold"
                >PatternForSemanticChronology</emphasis>). This feature asserts patterns that
            Semantic components can follow, similar to an XML or RDF Schema.</para>
        <para>
            <figure>
                <title>Semantic Definition</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Semantic_Definition.png" format="PNG" scalefit="1"
                            width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Semantic Definition</emphasis></para>
                </caption>
            </figure>
        </para>
        <?oxy_comment_start author="timowilliams" timestamp="20210202T170910-0600" comment="inserting an image would be helpful here"?>
        <para>Using this mechanism Semantics of varying structures can be defined using the
            PatternForSemantic. The PatternForSemantic is used to define each field as to what its
            purpose, data type, and meaning. For example, if a field within a semantic is used to
            describe an SDO's website, the Meaning would be "URL, DataType of "String", and Purpose
            of "Website".<?oxy_comment_end?>  The PatternForSemantic would then contain an array of
            these FieldDefinitions.</para>
    </section>
    <section>
        <title>Overall Tinkar Architecture</title>
        <para>
            <figure>
                <title>Overall Tinkar Architecture</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Tinkar_Architecture.png" format="PNG" scalefit="1" width="100%" contentdepth="100%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para><emphasis role="italics">Overall Tinkar Architecture</emphasis></para>
                </caption>
            </figure></para>
    </section>
    <section>
        <title>Coordinate</title>
        <para>Tinkar supports and encourages the storage of time series data that utilizes multiple
            dimensions, for example: STAMP, Language, Dialect, clinical domains, etc. The ability to
            efficiently search, display, and navigate concepts and semantics requires the ability to
            calculate particular combinations of content based on one or more of these different
            dimensions. </para>
        <para>A versioned graph enables us to recover the state of the graph at a particular point
            in time. Most graph databases don’t support versioning as a first-class concept: it is
            possible, however, to create a versioning scheme inside the graph model whereby nodes
            and relationships are timestamped and archived whenever they are modified. The downside
            of such versioning schemes is that they leak into any queries written against the graph,
            adding a layer of complexity to even the simplest query.</para>
        <para>Types of Coordinates:<itemizedlist>
                <listitem>
                    <para>STAMP coordinates are the most basic type of coordinate that all content
                        should be filtered. Example of STAMP coordinates are:<itemizedlist>
                            <listitem>
                                <para>most recent version</para>
                            </listitem>
                            <listitem>
                                <para>set of data from several versions</para>
                            </listitem>
                            <listitem>
                                <para>all active components only</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>Language coordinates are used to control the terms that should be
                        displayed. Examples of Language coordinates are:<itemizedlist>
                            <listitem>
                                <para>displaying terms based on a language and/or dialect</para>
                            </listitem>
                            <listitem>
                                <para>prioritized list of synonyms based on a particular clinical
                                    domain</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>Logic coordinates are used to identify the various results from
                        Description Logic Classifiers as well as the different versions of the
                        output over time.</para>
                    <itemizedlist>
                        <listitem>
                            <para>Result from various Description Logic Classifiers</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para>Navigation coordinates are used to assist in the viewing and searching for
                        a particular concept. Examples of these would be:<itemizedlist>
                            <listitem>
                                <para>Stated vs inferred relationships from SNOMED</para>
                            </listitem>
                            <listitem>
                                <para>Concepts inclusion/exclusion for a particular domain</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
            </itemizedlist></para>
        <section>
            <title>Calculating Coordinates</title>
            <para>The ComponentChronology contains all the versions of a component from the date is
                was instantiated until the most recent version. Components only get a new version
                whenever something about the component changes. To calculate the latest version
                requires the ability to find the most recent version of each component. Utilizing
                the STAMP Coordinates supports calculating all other coordinates:</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Identify the Module(s) you would like to view/search/modify</para>
                    </listitem>
                    <listitem>
                        <para>Identify the Path you would like to view/search/modify</para>
                    </listitem>
                    <listitem>
                        <para>Identify the Status or Statuses you would like to
                            view/search/modify</para>
                    </listitem>
                    <listitem>
                        <para>If relevant, identify the Author(s) you would like to
                            view/search/modify</para>
                    </listitem>
                    <listitem>
                        <para>The last piece of the STAMP coordinate (time) is the most difficult to
                            calculate. In most cases you will need to find the most recent version
                            of the component as of the current time in order to calculate this point
                            of the coordinate. However, since Tinkar supports and encourages the
                            representation of historical, you may need to calculate the most recent
                            version as of a different point in time. </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>After the STAMP Coordinates have been calculated additional coordinates can then
                be applied as well. For example, applying a language and dialect coordinate will be
                important not only for viewing and searching, but also to determine the appropriate
                preferred name for displaying a hieararchy. </para>
        </section>
    </section>
    <section>
        <title>Tabular Requirements</title>
        <informaltable>
            <tgroup cols="4">
                <colspec colnum="1" colname="col1"/>
                <colspec colnum="2" colname="col2"/>
                <colspec colnum="3" colname="col3"/>
                <colspec colnum="4" colname="col4"/>
                <tbody>
                    <row>
                        <entry><emphasis role="bold">ID</emphasis></entry>
                        <entry><emphasis role="bold">ID2</emphasis></entry>
                        <entry><emphasis role="bold">Requirement</emphasis></entry>
                        <entry><emphasis role="bold">Level</emphasis></entry>
                    </row>
                    <row>
                        <entry>1</entry>
                        <entry/>
                        <entry><emphasis role="underline">support the coordination of safe,
                                effective medicine </emphasis></entry>
                        <entry>Need</entry>
                    </row>
                    <row>
                        <entry>2</entry>
                        <entry/>
                        <entry><emphasis role="underline">quality information in the patient
                                record</emphasis></entry>
                        <entry>Need</entry>
                    </row>
                    <row>
                        <entry>3</entry>
                        <entry/>
                        <entry><emphasis role="underline">commonly understood data
                                standards</emphasis></entry>
                        <entry>Feature</entry>
                    </row>
                    <row>
                        <entry>4</entry>
                        <entry/>
                        <entry><emphasis role="underline">support detailed change management on
                                information assets</emphasis></entry>
                        <entry>Feature</entry>
                    </row>
                    <row>
                        <entry>5</entry>
                        <entry/>
                        <entry><emphasis role="underline">to record and review data quickly and
                                accurately</emphasis></entry>
                        <entry>Need</entry>
                    </row>
                    <row>
                        <entry>6</entry>
                        <entry/>
                        <entry><emphasis role="underline">knowing when a change in the knowledge
                                base might affect a record</emphasis></entry>
                        <entry>Need</entry>
                    </row>
                    <row>
                        <entry>7</entry>
                        <entry/>
                        <entry><emphasis role="underline">terms available are
                            appropriate</emphasis></entry>
                        <entry>Feature</entry>
                    </row>
                    <row>
                        <entry>8</entry>
                        <entry/>
                        <entry>a term that is not supported by the enterprise terminology, the
                                <emphasis role="underline">effort will be
                            captured</emphasis></entry>
                        <entry>Feature</entry>
                    </row>
                    <row>
                        <entry>9</entry>
                        <entry/>
                        <entry><emphasis role="underline">terms available are appropriate
                                (duplicate)</emphasis></entry>
                        <entry/>
                    </row>
                    <row>
                        <entry>10</entry>
                        <entry/>
                        <entry><emphasis role="underline">Changes to the terminology that could
                                affect record interpretation will be indicated</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>11</entry>
                        <entry/>
                        <entry>ability to <emphasis role="underline">see available values and CDS
                                results for specific dates and contexts</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>12</entry>
                        <entry/>
                        <entry>availability of <emphasis role="underline">assets from prior points
                                in time </emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>13</entry>
                        <entry/>
                        <entry>assets as <emphasis role="underline">defined or refined by different
                                stakeholders </emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>14</entry>
                        <entry/>
                        <entry><emphasis role="underline">manage change
                            systematically</emphasis></entry>
                        <entry>Feature</entry>
                    </row>
                    <row>
                        <entry>15</entry>
                        <entry/>
                        <entry><emphasis role="underline">importing standard
                                terminologies</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>16</entry>
                        <entry/>
                        <entry><emphasis role="underline">modifying the enterprise
                                terminologies</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>17</entry>
                        <entry/>
                        <entry><emphasis role="underline">publishing the enterprise
                                terminologies</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>18</entry>
                        <entry/>
                        <entry><emphasis role="underline">A complete record of all changes,
                                including relevant context information</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>19</entry>
                        <entry/>
                        <entry><emphasis role="underline">A single syntax to support the
                                representation of all terminology assets, known and
                                future</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>20</entry>
                        <entry/>
                        <entry><emphasis role="underline">Status</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>21</entry>
                        <entry/>
                        <entry><emphasis role="underline">Time</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>22</entry>
                        <entry/>
                        <entry><emphasis role="underline">Author</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>23</entry>
                        <entry/>
                        <entry><emphasis role="underline">Module</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>24</entry>
                        <entry/>
                        <entry><emphasis role="underline">Path</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>25</entry>
                        <entry/>
                        <entry><emphasis role="underline">asset must itself be
                                identifiable</emphasis></entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>26</entry>
                        <entry/>
                        <entry>All Tinkar assets have STAMP values</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>27</entry>
                        <entry/>
                        <entry>assets in Tinkar must be identifiable (duplicate)</entry>
                        <entry/>
                    </row>
                    <row>
                        <entry>28</entry>
                        <entry/>
                        <entry>Published terminologies, with all existing features</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>29</entry>
                        <entry/>
                        <entry>Enumerated sets of concepts for specified purposes, a.k.a., value
                            sets or refsets</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>30</entry>
                        <entry/>
                        <entry>Sets of associations or constraints composing an intensional
                            definition of a value set</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>31</entry>
                        <entry/>
                        <entry>Sets of associations or constraints composing a logical definition of
                            a concept</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>32</entry>
                        <entry/>
                        <entry>Sets of information about a concept as specified by a system; e.g.,
                            names (long, short, related, synonyms), codes, definitional properties,
                            recommendations or constraints on use of units, change types</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>33</entry>
                        <entry/>
                        <entry>Sets of information about metadata elements, such as the language of
                            a term or steward of a module</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>34</entry>
                        <entry/>
                        <entry>Associations among concepts, including relationships defined by
                            member systems (LOINC system, MedRT mechanism of action, SNOMED CT
                            finding site).</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>35</entry>
                        <entry/>
                        <entry>Associations among concepts, including classification &amp;
                            equivalence maps defined to harmonize and coordinate concepts common to
                            different systems.</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>36</entry>
                        <entry/>
                        <entry>Sets of sets, supporting maps with multiple members. E.g., a set of
                            Names may include a single preferred name and a contained set of
                            synonyms. [Specific use cases should illustrate how our Semantics will
                            probably have several layers]</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>37</entry>
                        <entry/>
                        <entry>Constraints on values</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>37</entry>
                        <entry>a</entry>
                        <entry>Logical compositional constraints on valid concepts, e.g., the SNOMED
                            CT concept model</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>37</entry>
                        <entry>b</entry>
                        <entry>Syntactic compositional constraints on strings, e.g., MIME types, ISO
                            languages, or UCUM units</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>37</entry>
                        <entry>c</entry>
                        <entry>[Magnitudes? Dates?]</entry>
                        <entry/>
                    </row>
                    <row>
                        <entry>37</entry>
                        <entry>d</entry>
                        <entry>Structural constraints, e.g., presence of exactly one name classified
                            as “fully specified,” or names in specified languages</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>37</entry>
                        <entry>e</entry>
                        <entry>Rules that may govern modifications to other assets, e.g.,
                            incremental addition of effort estimates based on known problematic
                            terms.</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>37</entry>
                        <entry>f</entry>
                        <entry>Constraints depend on (refer to) values to be constrained; values are
                            not bound to constraints in ways that cannot be filtered out</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>37</entry>
                        <entry>g</entry>
                        <entry>Users can select contexts in which sets of constraints may or may not
                            be applied</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry/>
                        <entry>Modify component</entry>
                        <entry>Feature</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>a</entry>
                        <entry>An addition is a new version with a new chronology UUID.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>ai</entry>
                        <entry>Semantics may assert rules for additions to Modules, Paths, or other
                            sets, e.g.,</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>ai1</entry>
                        <entry>A concept must have at least one name</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>ai2</entry>
                        <entry>A concept must have at least one parent</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>ai3</entry>
                        <entry>A Concept logical definition Semantic must have a definition
                            status</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>b</entry>
                        <entry>A deletion is a new version of an existing chronology with status set
                            to “inactive.”</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>bi</entry>
                        <entry>Semantics may assert rules for deletions from Modules, Paths, or
                            other sets, e.g.,</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>bi1</entry>
                        <entry>Children of deactivated concepts must be assigned a new
                            parent</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>c</entry>
                        <entry>A change is a new version of an existing chronology with the new
                            value(s), distinguishable by the time (and possibly other STAMP
                            values).</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>ci</entry>
                        <entry>A change may involve only a STAMP value; e.g., deactivation, or
                            transfer of a concept to a new module or path.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>38</entry>
                        <entry>ci1</entry>
                        <entry>Transfer involves a new version and a decision about whether to
                            deactivate the old one.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry/>
                        <entry>Any modification must be followed by identification of dependent
                            relationships.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>a</entry>
                        <entry>A dependent relationship is a Semantic assertion that refers to a
                            prior version of a changed component.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>b</entry>
                        <entry>Semantics should specify approaches for handling kinds of
                            changes.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>bi</entry>
                        <entry>Dependent relationships with rules may be handled
                            automatically.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>bii</entry>
                        <entry>Dependent relationships without rules must be handled
                            manually.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>c</entry>
                        <entry>Multiple dependent relationships must be ordered to prevent redundant
                            handling.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>ci</entry>
                        <entry>If dependent relationship [A] also depends on a second dependent
                            relationship [B], then dependent relationship [B] should be addressed
                            first.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>d</entry>
                        <entry>Semantics are specific to module and path, so their rules are as
                            well.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>di</entry>
                        <entry>Rules may include or exclude modules or paths from their dependency
                            graphs.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>e</entry>
                        <entry>Rules will be applied at the time the change is recognized.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>ei</entry>
                        <entry>Terminology authoring activities will apply these rules at the time
                            of authoring.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>eii</entry>
                        <entry>Export and publication activities may apply additional rules at the
                            time of export or publication. These operations may be the equivalent of
                            modifying the Path of a set of assets (i.e., creating a new set of
                            versions specifying the new Path).</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>eiii</entry>
                        <entry>Import activities may apply import rules at the time of
                            import.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>39</entry>
                        <entry>eiv</entry>
                        <entry>The timeframe for rule disposition may be defined by the
                            rule.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>40</entry>
                        <entry/>
                        <entry>Publication is the copying of a set of Versions with a new
                            Path.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>40</entry>
                        <entry>a</entry>
                        <entry>Publication may invoke a specified set of rules or a higher level of
                            stringency for previously applied rules.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>40</entry>
                        <entry>b</entry>
                        <entry>Publication may or may not imply deactivation of the Versions in the
                            prior path.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>41</entry>
                        <entry/>
                        <entry>Export is the serialization of a data set (typically a published
                            module or set of modules) into a file suitable for automated consumption
                            by another terminology management system.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>41</entry>
                        <entry>a</entry>
                        <entry>This serialization will conform to [specification]</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>42</entry>
                        <entry/>
                        <entry>Import is the automated consumption of an exported data set by a
                            terminology management system.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry/>
                        <entry>[Context | Coordinate] management</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry>a</entry>
                        <entry>A minimal set of STAMP values (time, module, and path) is required to
                            determine the validity of any operation or Semantic.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry>ai</entry>
                        <entry>Author may be used for this purpose, but is unlikely to be
                            useful.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry>aii</entry>
                        <entry>Status may be used to distinguish between “active-only” and “all”
                            views.</entry>
                        <entry>Implementation</entry>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry>b</entry>
                        <entry>A module dependency Semantic may be used to determine what modules
                            depend on others – i.e., adopt assertions in the independent module.
                            Such a Semantic must be acyclic.</entry>
                        <entry>Design</entry>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry>c</entry>
                        <entry>[similar functionality for Paths?]</entry>
                        <entry/>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry>d</entry>
                        <entry>A user will be able to determine what modules a service supports,
                            with their dependencies</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry>di</entry>
                        <entry>Within the module, specific paths</entry>
                        <entry>Requirement</entry>
                    </row>
                    <row>
                        <entry>43</entry>
                        <entry>dii</entry>
                        <entry>Within the module, sets of Semantics defined by grouping Semantics,
                            e.g., for specific use cases (such as quality measures) or
                            specialties.</entry>
                        <entry>Requirement</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
    </section>
</chapter>
